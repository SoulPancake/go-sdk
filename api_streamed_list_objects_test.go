/**
 * Go SDK for OpenFGA
 *
 * API version: 1.x
 * Website: https://openfga.dev
 * Documentation: https://openfga.dev/docs
 * Support: https://openfga.dev/community
 * License: [Apache-2.0](https://github.com/openfga/go-sdk/blob/main/LICENSE)
 *
 * NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 */

package openfga

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"
)

func TestStreamedListObjects(t *testing.T) {
	t.Run("StreamedListObjects - Success with multiple objects", func(t *testing.T) {
		objects := []string{
			"document:roadmap",
			"document:budget",
			"document:plan",
		}

		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if r.Method != http.MethodPost {
				t.Errorf("Expected POST request, got %s", r.Method)
			}
			if !strings.HasSuffix(r.URL.Path, "/streamed-list-objects") {
				t.Errorf("Expected path to end with /streamed-list-objects, got %s", r.URL.Path)
			}

			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusOK)

			for _, obj := range objects {
				response := StreamedListObjectsResponse{Object: obj}
				data, _ := json.Marshal(response)
				w.Write(data)
				w.Write([]byte("\n"))
				if f, ok := w.(http.Flusher); ok {
					f.Flush()
				}
			}
		}))
		defer server.Close()

		configuration, err := NewConfiguration(Configuration{
			ApiUrl: server.URL,
		})
		if err != nil {
			t.Fatalf("Failed to create configuration: %v", err)
		}

		apiClient := NewAPIClient(configuration)
		storeId := "01GXSB9YR785C4FYS3C0RTG7B2"

		body := ListObjectsRequest{
			User:     "user:anne",
			Relation: "viewer",
			Type:     "document",
		}

		objectChan, errorChan := apiClient.OpenFgaApi.StreamedListObjects(context.Background(), storeId).
			Body(body).
			Execute()

		receivedObjects := []string{}
		done := false
		for !done {
			select {
			case obj, ok := <-objectChan:
				if !ok {
					done = true
					break
				}
				receivedObjects = append(receivedObjects, obj.Object)
			case err := <-errorChan:
				if err != nil {
					t.Fatalf("Error received: %v", err)
				}
			case <-time.After(5 * time.Second):
				t.Fatalf("Test timed out")
			}
		}

		if len(receivedObjects) != len(objects) {
			t.Fatalf("Expected %d objects, got %d", len(objects), len(receivedObjects))
		}

		for i, expected := range objects {
			if receivedObjects[i] != expected {
				t.Errorf("Object %d: expected %s, got %s", i, expected, receivedObjects[i])
			}
		}
	})

	t.Run("StreamedListObjects - Empty response", func(t *testing.T) {
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusOK)
		}))
		defer server.Close()

		configuration, err := NewConfiguration(Configuration{
			ApiUrl: server.URL,
		})
		if err != nil {
			t.Fatalf("Failed to create configuration: %v", err)
		}

		apiClient := NewAPIClient(configuration)
		storeId := "01GXSB9YR785C4FYS3C0RTG7B2"

		body := ListObjectsRequest{
			User:     "user:bob",
			Relation: "viewer",
			Type:     "document",
		}

		objectChan, errorChan := apiClient.OpenFgaApi.StreamedListObjects(context.Background(), storeId).
			Body(body).
			Execute()

		receivedObjects := []string{}
		done := false
		for !done {
			select {
			case obj, ok := <-objectChan:
				if !ok {
					done = true
					break
				}
				receivedObjects = append(receivedObjects, obj.Object)
			case err := <-errorChan:
				if err != nil {
					t.Fatalf("Error received: %v", err)
				}
			case <-time.After(5 * time.Second):
				t.Fatalf("Test timed out")
			}
		}

		if len(receivedObjects) != 0 {
			t.Fatalf("Expected 0 objects, got %d", len(receivedObjects))
		}
	})

	t.Run("StreamedListObjects - Error response", func(t *testing.T) {
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte(`{"code":"validation_error","message":"Invalid request"}`))
		}))
		defer server.Close()

		configuration, err := NewConfiguration(Configuration{
			ApiUrl: server.URL,
		})
		if err != nil {
			t.Fatalf("Failed to create configuration: %v", err)
		}

		apiClient := NewAPIClient(configuration)
		storeId := "01GXSB9YR785C4FYS3C0RTG7B2"

		body := ListObjectsRequest{
			User:     "invalid",
			Relation: "viewer",
			Type:     "document",
		}

		objectChan, errorChan := apiClient.OpenFgaApi.StreamedListObjects(context.Background(), storeId).
			Body(body).
			Execute()

		done := false
		errorReceived := false
		for !done {
			select {
			case _, ok := <-objectChan:
				if !ok {
					done = true
					break
				}
				t.Fatalf("Should not receive objects on error")
			case err := <-errorChan:
				if err != nil {
					errorReceived = true
				}
			case <-time.After(5 * time.Second):
				t.Fatalf("Test timed out")
			}
		}

		if !errorReceived {
			t.Fatalf("Expected error to be received")
		}
	})

	t.Run("StreamedListObjects - Context cancellation", func(t *testing.T) {
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusOK)

			for i := 0; i < 10; i++ {
				response := StreamedListObjectsResponse{Object: fmt.Sprintf("document:%d", i)}
				data, _ := json.Marshal(response)
				w.Write(data)
				w.Write([]byte("\n"))
				if f, ok := w.(http.Flusher); ok {
					f.Flush()
				}
				time.Sleep(100 * time.Millisecond)
			}
		}))
		defer server.Close()

		configuration, err := NewConfiguration(Configuration{
			ApiUrl: server.URL,
		})
		if err != nil {
			t.Fatalf("Failed to create configuration: %v", err)
		}

		apiClient := NewAPIClient(configuration)
		storeId := "01GXSB9YR785C4FYS3C0RTG7B2"

		ctx, cancel := context.WithCancel(context.Background())

		body := ListObjectsRequest{
			User:     "user:anne",
			Relation: "viewer",
			Type:     "document",
		}

		objectChan, errorChan := apiClient.OpenFgaApi.StreamedListObjects(ctx, storeId).
			Body(body).
			Execute()

		receivedObjects := 0
		cancel()

		done := false
		for !done {
			select {
			case _, ok := <-objectChan:
				if !ok {
					done = true
					break
				}
				receivedObjects++
			case <-errorChan:
			case <-time.After(2 * time.Second):
				done = true
			}
		}
	})

	t.Run("StreamedListObjects - Missing storeId", func(t *testing.T) {
		configuration, err := NewConfiguration(Configuration{
			ApiUrl: "http://localhost:8080",
		})
		if err != nil {
			t.Fatalf("Failed to create configuration: %v", err)
		}

		apiClient := NewAPIClient(configuration)

		body := ListObjectsRequest{
			User:     "user:anne",
			Relation: "viewer",
			Type:     "document",
		}

		objectChan, errorChan := apiClient.OpenFgaApi.StreamedListObjects(context.Background(), "").
			Body(body).
			Execute()

		done := false
		errorReceived := false
		for !done {
			select {
			case _, ok := <-objectChan:
				if !ok {
					done = true
					break
				}
			case err := <-errorChan:
				if err != nil {
					errorReceived = true
					if !strings.Contains(err.Error(), "storeId") {
						t.Errorf("Expected error about storeId, got: %v", err)
					}
				}
			case <-time.After(2 * time.Second):
				t.Fatalf("Test timed out")
			}
		}

		if !errorReceived {
			t.Fatalf("Expected error for missing storeId")
		}
	})

	t.Run("StreamedListObjects - With authorization model ID", func(t *testing.T) {
		objects := []string{"document:roadmap"}
		modelId := "01GXSA8YR785C4FYS3C0RTG7B1"

		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			var reqBody map[string]interface{}
			json.NewDecoder(r.Body).Decode(&reqBody)

			if reqBody["authorization_model_id"] != modelId {
				t.Errorf("Expected authorization_model_id %s, got %v", modelId, reqBody["authorization_model_id"])
			}

			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusOK)

			for _, obj := range objects {
				response := StreamedListObjectsResponse{Object: obj}
				data, _ := json.Marshal(response)
				w.Write(data)
				w.Write([]byte("\n"))
			}
		}))
		defer server.Close()

		configuration, err := NewConfiguration(Configuration{
			ApiUrl: server.URL,
		})
		if err != nil {
			t.Fatalf("Failed to create configuration: %v", err)
		}

		apiClient := NewAPIClient(configuration)
		storeId := "01GXSB9YR785C4FYS3C0RTG7B2"

		body := ListObjectsRequest{
			User:                 "user:anne",
			Relation:             "viewer",
			Type:                 "document",
			AuthorizationModelId: PtrString(modelId),
		}

		objectChan, errorChan := apiClient.OpenFgaApi.StreamedListObjects(context.Background(), storeId).
			Body(body).
			Execute()

		receivedObjects := []string{}
		done := false
		for !done {
			select {
			case obj, ok := <-objectChan:
				if !ok {
					done = true
					break
				}
				receivedObjects = append(receivedObjects, obj.Object)
			case err := <-errorChan:
				if err != nil {
					t.Fatalf("Error received: %v", err)
				}
			case <-time.After(5 * time.Second):
				t.Fatalf("Test timed out")
			}
		}

		if len(receivedObjects) != len(objects) {
			t.Fatalf("Expected %d objects, got %d", len(objects), len(receivedObjects))
		}
	})
}

func TestStreamedListObjectsResponse(t *testing.T) {
	t.Run("StreamedListObjectsResponse - Marshal and Unmarshal", func(t *testing.T) {
		response := NewStreamedListObjectsResponse("document:roadmap")

		data, err := response.MarshalJSON()
		if err != nil {
			t.Fatalf("Failed to marshal response: %v", err)
		}

		var unmarshaled StreamedListObjectsResponse
		err = json.Unmarshal(data, &unmarshaled)
		if err != nil {
			t.Fatalf("Failed to unmarshal response: %v", err)
		}

		if unmarshaled.Object != response.Object {
			t.Errorf("Expected object %s, got %s", response.Object, unmarshaled.Object)
		}
	})

	t.Run("StreamedListObjectsResponse - Getters and Setters", func(t *testing.T) {
		response := NewStreamedListObjectsResponseWithDefaults()
		
		response.SetObject("document:budget")
		
		if response.GetObject() != "document:budget" {
			t.Errorf("Expected object document:budget, got %s", response.GetObject())
		}

		objPtr, ok := response.GetObjectOk()
		if !ok || *objPtr != "document:budget" {
			t.Errorf("GetObjectOk failed")
		}
	})

	t.Run("StreamedListObjectsResponse - Nullable", func(t *testing.T) {
		response := NewStreamedListObjectsResponse("document:test")
		nullable := NewNullableStreamedListObjectsResponse(response)

		if !nullable.IsSet() {
			t.Errorf("Expected nullable to be set")
		}

		if nullable.Get().Object != "document:test" {
			t.Errorf("Expected object document:test, got %s", nullable.Get().Object)
		}

		data, err := nullable.MarshalJSON()
		if err != nil {
			t.Fatalf("Failed to marshal nullable: %v", err)
		}

		var unmarshaled NullableStreamedListObjectsResponse
		err = unmarshaled.UnmarshalJSON(data)
		if err != nil {
			t.Fatalf("Failed to unmarshal nullable: %v", err)
		}

		if !unmarshaled.IsSet() {
			t.Errorf("Expected unmarshaled nullable to be set")
		}

		unmarshaled.Unset()
		if unmarshaled.IsSet() {
			t.Errorf("Expected unmarshaled nullable to be unset")
		}
	})
}
