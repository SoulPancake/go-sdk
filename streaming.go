/**
 * Go SDK for OpenFGA
 *
 * API version: 1.x
 * Website: https://openfga.dev
 * Documentation: https://openfga.dev/docs
 * Support: https://openfga.dev/community
 * License: [Apache-2.0](https://github.com/openfga/go-sdk/blob/main/LICENSE)
 *
 * NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 */

package openfga

import (
	"bufio"
	"context"
	"encoding/json"
	"errors"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type StreamedListObjectsChannel struct {
	Objects chan StreamedListObjectsResponse
	Errors  chan error
	cancel  context.CancelFunc
}

func (s *StreamedListObjectsChannel) Close() {
	if s.cancel != nil {
		s.cancel()
	}
}

func (a *OpenFgaApiService) StreamedListObjectsWithChannel(r ApiStreamedListObjectsRequest) (*StreamedListObjectsChannel, *http.Response, error) {
	ctx, cancel := context.WithCancel(r.ctx)

	_, httpResponse, err := a.prepareStreamedListObjectsRequest(r)
	if err != nil {
		cancel()
		return nil, httpResponse, err
	}

	channel := &StreamedListObjectsChannel{
		Objects: make(chan StreamedListObjectsResponse, 10),
		Errors:  make(chan error, 1),
		cancel:  cancel,
	}

	go func() {
		defer close(channel.Objects)
		defer close(channel.Errors)
		defer cancel()

		if httpResponse.Body == nil {
			channel.Errors <- errors.New("response body is nil")
			return
		}
		defer httpResponse.Body.Close()

		scanner := bufio.NewScanner(httpResponse.Body)
		for scanner.Scan() {
			select {
			case <-ctx.Done():
				channel.Errors <- ctx.Err()
				return
			default:
				line := scanner.Bytes()
				if len(line) == 0 {
					continue
				}

				var streamResult StreamResultOfStreamedListObjectsResponse
				if err := json.Unmarshal(line, &streamResult); err != nil {
					channel.Errors <- err
					return
				}

				if streamResult.Error != nil {
					msg := "stream error"
					if streamResult.Error.Message != nil {
						msg = *streamResult.Error.Message
					}
					channel.Errors <- errors.New(msg)
					return
				}

				if streamResult.Result != nil {
					select {
					case <-ctx.Done():
						channel.Errors <- ctx.Err()
						return
					case channel.Objects <- *streamResult.Result:
					}
				}
			}
		}

		if err := scanner.Err(); err != nil {
			channel.Errors <- err
		}
	}()

	return channel, httpResponse, nil
}

func (a *OpenFgaApiService) prepareStreamedListObjectsRequest(r ApiStreamedListObjectsRequest) (*http.Request, *http.Response, error) {
	path := "/stores/{store_id}/streamed-list-objects"
	if r.storeId == "" {
		return nil, nil, reportError("storeId is required and must be specified")
	}

	path = strings.ReplaceAll(path, "{"+"store_id"+"}", url.PathEscape(parameterToString(r.storeId, "")))

	if r.body == nil {
		return nil, nil, reportError("body is required and must be specified")
	}

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}

	localVarHTTPContentType := "application/json"
	localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	localVarHeaderParams["Accept"] = "application/x-ndjson"

	for header, val := range r.options.Headers {
		localVarHeaderParams[header] = val
	}

	req, err := a.client.prepareRequest(r.ctx, path, http.MethodPost, r.body, localVarHeaderParams, localVarQueryParams)
	if err != nil {
		return nil, nil, err
	}

	httpResponse, err := a.client.callAPI(req)
	if err != nil || httpResponse == nil {
		return req, httpResponse, err
	}

	if httpResponse.StatusCode >= http.StatusMultipleChoices {
		responseBody, readErr := io.ReadAll(httpResponse.Body)
		_ = httpResponse.Body.Close()
		if readErr != nil {
			return req, httpResponse, readErr
		}
		err = a.client.handleAPIError(httpResponse, responseBody, r.body, "StreamedListObjects", r.storeId)
		return req, httpResponse, err
	}

	return req, httpResponse, nil
}
