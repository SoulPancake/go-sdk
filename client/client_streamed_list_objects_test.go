/**
 * Go SDK for OpenFGA
 *
 * API version: 1.x
 * Website: https://openfga.dev
 * Documentation: https://openfga.dev/docs
 * Support: https://openfga.dev/community
 * License: [Apache-2.0](https://github.com/openfga/go-sdk/blob/main/LICENSE)
 *
 * NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 */

package client_test

import (
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	openfga "github.com/openfga/go-sdk"
	. "github.com/openfga/go-sdk/client"
)

func TestStreamedListObjects(t *testing.T) {
	t.Run("StreamedListObjects - Success", func(t *testing.T) {
		objects := []string{
			"document:roadmap",
			"document:budget",
			"document:plan",
		}

		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if r.Method != http.MethodPost {
				t.Errorf("Expected POST request, got %s", r.Method)
			}

			var reqBody map[string]interface{}
			json.NewDecoder(r.Body).Decode(&reqBody)

			if reqBody["user"] != "user:anne" {
				t.Errorf("Expected user:anne, got %v", reqBody["user"])
			}
			if reqBody["relation"] != "viewer" {
				t.Errorf("Expected relation viewer, got %v", reqBody["relation"])
			}
			if reqBody["type"] != "document" {
				t.Errorf("Expected type document, got %v", reqBody["type"])
			}

			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusOK)

			for _, obj := range objects {
				response := map[string]string{"object": obj}
				data, _ := json.Marshal(response)
				w.Write(data)
				w.Write([]byte("\n"))
				if f, ok := w.(http.Flusher); ok {
					f.Flush()
				}
			}
		}))
		defer server.Close()

		fgaClient, err := NewSdkClient(&ClientConfiguration{
			ApiUrl:  server.URL,
			StoreId: "01GXSB9YR785C4FYS3C0RTG7B2",
		})
		if err != nil {
			t.Fatalf("Failed to create client: %v", err)
		}

		objectChan, errorChan := fgaClient.StreamedListObjects(context.Background()).
			Body(ClientStreamedListObjectsRequest{
				User:     "user:anne",
				Relation: "viewer",
				Type:     "document",
			}).
			Execute()

		receivedObjects := []string{}
		done := false
		for !done {
			select {
			case obj, ok := <-objectChan:
				if !ok {
					done = true
					break
				}
				receivedObjects = append(receivedObjects, obj.Object)
			case err := <-errorChan:
				if err != nil {
					t.Fatalf("Error received: %v", err)
				}
			case <-time.After(5 * time.Second):
				t.Fatalf("Test timed out")
			}
		}

		if len(receivedObjects) != len(objects) {
			t.Fatalf("Expected %d objects, got %d", len(objects), len(receivedObjects))
		}

		for i, expected := range objects {
			if receivedObjects[i] != expected {
				t.Errorf("Object %d: expected %s, got %s", i, expected, receivedObjects[i])
			}
		}
	})

	t.Run("StreamedListObjects - With AuthorizationModelId", func(t *testing.T) {
		modelId := "01GXSA8YR785C4FYS3C0RTG7B1"
		objects := []string{"document:roadmap"}

		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			var reqBody map[string]interface{}
			json.NewDecoder(r.Body).Decode(&reqBody)

			if reqBody["authorization_model_id"] != modelId {
				t.Errorf("Expected authorization_model_id %s, got %v", modelId, reqBody["authorization_model_id"])
			}

			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusOK)

			for _, obj := range objects {
				response := map[string]string{"object": obj}
				data, _ := json.Marshal(response)
				w.Write(data)
				w.Write([]byte("\n"))
			}
		}))
		defer server.Close()

		fgaClient, err := NewSdkClient(&ClientConfiguration{
			ApiUrl:               server.URL,
			StoreId:              "01GXSB9YR785C4FYS3C0RTG7B2",
			AuthorizationModelId: modelId,
		})
		if err != nil {
			t.Fatalf("Failed to create client: %v", err)
		}

		objectChan, errorChan := fgaClient.StreamedListObjects(context.Background()).
			Body(ClientStreamedListObjectsRequest{
				User:     "user:anne",
				Relation: "viewer",
				Type:     "document",
			}).
			Execute()

		receivedObjects := []string{}
		done := false
		for !done {
			select {
			case obj, ok := <-objectChan:
				if !ok {
					done = true
					break
				}
				receivedObjects = append(receivedObjects, obj.Object)
			case err := <-errorChan:
				if err != nil {
					t.Fatalf("Error received: %v", err)
				}
			case <-time.After(5 * time.Second):
				t.Fatalf("Test timed out")
			}
		}

		if len(receivedObjects) != len(objects) {
			t.Fatalf("Expected %d objects, got %d", len(objects), len(receivedObjects))
		}
	})

	t.Run("StreamedListObjects - With ContextualTuples", func(t *testing.T) {
		objects := []string{"document:roadmap"}

		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			var reqBody map[string]interface{}
			json.NewDecoder(r.Body).Decode(&reqBody)

			contextualTuples, ok := reqBody["contextual_tuples"].(map[string]interface{})
			if !ok {
				t.Errorf("Expected contextual_tuples to be present")
			}

			tupleKeys, ok := contextualTuples["tuple_keys"].([]interface{})
			if !ok || len(tupleKeys) == 0 {
				t.Errorf("Expected tuple_keys to be present and non-empty")
			}

			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusOK)

			for _, obj := range objects {
				response := map[string]string{"object": obj}
				data, _ := json.Marshal(response)
				w.Write(data)
				w.Write([]byte("\n"))
			}
		}))
		defer server.Close()

		fgaClient, err := NewSdkClient(&ClientConfiguration{
			ApiUrl:  server.URL,
			StoreId: "01GXSB9YR785C4FYS3C0RTG7B2",
		})
		if err != nil {
			t.Fatalf("Failed to create client: %v", err)
		}

		objectChan, errorChan := fgaClient.StreamedListObjects(context.Background()).
			Body(ClientStreamedListObjectsRequest{
				User:     "user:anne",
				Relation: "viewer",
				Type:     "document",
				ContextualTuples: []ClientContextualTupleKey{
					{
						User:     "user:anne",
						Relation: "writer",
						Object:   "document:roadmap",
					},
				},
			}).
			Execute()

		receivedObjects := []string{}
		done := false
		for !done {
			select {
			case obj, ok := <-objectChan:
				if !ok {
					done = true
					break
				}
				receivedObjects = append(receivedObjects, obj.Object)
			case err := <-errorChan:
				if err != nil {
					t.Fatalf("Error received: %v", err)
				}
			case <-time.After(5 * time.Second):
				t.Fatalf("Test timed out")
			}
		}

		if len(receivedObjects) != len(objects) {
			t.Fatalf("Expected %d objects, got %d", len(objects), len(receivedObjects))
		}
	})

	t.Run("StreamedListObjects - With Context", func(t *testing.T) {
		objects := []string{"document:roadmap"}

		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			var reqBody map[string]interface{}
			json.NewDecoder(r.Body).Decode(&reqBody)

			contextObj, ok := reqBody["context"].(map[string]interface{})
			if !ok {
				t.Errorf("Expected context to be present")
			}

			if contextObj["ViewCount"] != float64(100) {
				t.Errorf("Expected ViewCount 100, got %v", contextObj["ViewCount"])
			}

			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusOK)

			for _, obj := range objects {
				response := map[string]string{"object": obj}
				data, _ := json.Marshal(response)
				w.Write(data)
				w.Write([]byte("\n"))
			}
		}))
		defer server.Close()

		fgaClient, err := NewSdkClient(&ClientConfiguration{
			ApiUrl:  server.URL,
			StoreId: "01GXSB9YR785C4FYS3C0RTG7B2",
		})
		if err != nil {
			t.Fatalf("Failed to create client: %v", err)
		}

		contextData := map[string]interface{}{"ViewCount": 100}
		objectChan, errorChan := fgaClient.StreamedListObjects(context.Background()).
			Body(ClientStreamedListObjectsRequest{
				User:     "user:anne",
				Relation: "viewer",
				Type:     "document",
				Context:  &contextData,
			}).
			Execute()

		receivedObjects := []string{}
		done := false
		for !done {
			select {
			case obj, ok := <-objectChan:
				if !ok {
					done = true
					break
				}
				receivedObjects = append(receivedObjects, obj.Object)
			case err := <-errorChan:
				if err != nil {
					t.Fatalf("Error received: %v", err)
				}
			case <-time.After(5 * time.Second):
				t.Fatalf("Test timed out")
			}
		}

		if len(receivedObjects) != len(objects) {
			t.Fatalf("Expected %d objects, got %d", len(objects), len(receivedObjects))
		}
	})

	t.Run("StreamedListObjects - With Consistency Option", func(t *testing.T) {
		objects := []string{"document:roadmap"}

		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			var reqBody map[string]interface{}
			json.NewDecoder(r.Body).Decode(&reqBody)

			if reqBody["consistency"] != "HIGHER_CONSISTENCY" {
				t.Errorf("Expected consistency HIGHER_CONSISTENCY, got %v", reqBody["consistency"])
			}

			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusOK)

			for _, obj := range objects {
				response := map[string]string{"object": obj}
				data, _ := json.Marshal(response)
				w.Write(data)
				w.Write([]byte("\n"))
			}
		}))
		defer server.Close()

		fgaClient, err := NewSdkClient(&ClientConfiguration{
			ApiUrl:  server.URL,
			StoreId: "01GXSB9YR785C4FYS3C0RTG7B2",
		})
		if err != nil {
			t.Fatalf("Failed to create client: %v", err)
		}

		consistency := openfga.CONSISTENCYPREFERENCE_HIGHER_CONSISTENCY
		objectChan, errorChan := fgaClient.StreamedListObjects(context.Background()).
			Body(ClientStreamedListObjectsRequest{
				User:     "user:anne",
				Relation: "viewer",
				Type:     "document",
			}).
			Options(ClientStreamedListObjectsOptions{
				Consistency: &consistency,
			}).
			Execute()

		receivedObjects := []string{}
		done := false
		for !done {
			select {
			case obj, ok := <-objectChan:
				if !ok {
					done = true
					break
				}
				receivedObjects = append(receivedObjects, obj.Object)
			case err := <-errorChan:
				if err != nil {
					t.Fatalf("Error received: %v", err)
				}
			case <-time.After(5 * time.Second):
				t.Fatalf("Test timed out")
			}
		}

		if len(receivedObjects) != len(objects) {
			t.Fatalf("Expected %d objects, got %d", len(objects), len(receivedObjects))
		}
	})

	t.Run("StreamedListObjects - Empty Results", func(t *testing.T) {
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusOK)
		}))
		defer server.Close()

		fgaClient, err := NewSdkClient(&ClientConfiguration{
			ApiUrl:  server.URL,
			StoreId: "01GXSB9YR785C4FYS3C0RTG7B2",
		})
		if err != nil {
			t.Fatalf("Failed to create client: %v", err)
		}

		objectChan, errorChan := fgaClient.StreamedListObjects(context.Background()).
			Body(ClientStreamedListObjectsRequest{
				User:     "user:bob",
				Relation: "viewer",
				Type:     "document",
			}).
			Execute()

		receivedObjects := []string{}
		done := false
		for !done {
			select {
			case obj, ok := <-objectChan:
				if !ok {
					done = true
					break
				}
				receivedObjects = append(receivedObjects, obj.Object)
			case err := <-errorChan:
				if err != nil {
					t.Fatalf("Error received: %v", err)
				}
			case <-time.After(5 * time.Second):
				t.Fatalf("Test timed out")
			}
		}

		if len(receivedObjects) != 0 {
			t.Fatalf("Expected 0 objects, got %d", len(receivedObjects))
		}
	})

	t.Run("StreamedListObjects - No Store ID Configured", func(t *testing.T) {
		fgaClient, err := NewSdkClient(&ClientConfiguration{
			ApiUrl: "http://localhost:8080",
		})
		if err != nil {
			t.Fatalf("Failed to create client: %v", err)
		}

		objectChan, errorChan := fgaClient.StreamedListObjects(context.Background()).
			Body(ClientStreamedListObjectsRequest{
				User:     "user:anne",
				Relation: "viewer",
				Type:     "document",
			}).
			Execute()

		done := false
		errorReceived := false
		for !done {
			select {
			case _, ok := <-objectChan:
				if !ok {
					done = true
					break
				}
			case err := <-errorChan:
				if err != nil {
					errorReceived = true
				}
			case <-time.After(2 * time.Second):
				t.Fatalf("Test timed out")
			}
		}

		if !errorReceived {
			t.Fatalf("Expected error for missing store ID")
		}
	})

	t.Run("StreamedListObjects - Authorization Model Override", func(t *testing.T) {
		modelId := "01GXSA8YR785C4FYS3C0RTG7B1"
		objects := []string{"document:roadmap"}

		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			var reqBody map[string]interface{}
			json.NewDecoder(r.Body).Decode(&reqBody)

			if reqBody["authorization_model_id"] != modelId {
				t.Errorf("Expected authorization_model_id %s, got %v", modelId, reqBody["authorization_model_id"])
			}

			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusOK)

			for _, obj := range objects {
				response := map[string]string{"object": obj}
				data, _ := json.Marshal(response)
				w.Write(data)
				w.Write([]byte("\n"))
			}
		}))
		defer server.Close()

		fgaClient, err := NewSdkClient(&ClientConfiguration{
			ApiUrl:               server.URL,
			StoreId:              "01GXSB9YR785C4FYS3C0RTG7B2",
			AuthorizationModelId: "01GXSA8YR785C4FYS3C0RTG7B0",
		})
		if err != nil {
			t.Fatalf("Failed to create client: %v", err)
		}

		objectChan, errorChan := fgaClient.StreamedListObjects(context.Background()).
			Body(ClientStreamedListObjectsRequest{
				User:     "user:anne",
				Relation: "viewer",
				Type:     "document",
			}).
			Options(ClientStreamedListObjectsOptions{
				AuthorizationModelIdOptions: AuthorizationModelIdOptions{
					AuthorizationModelId: openfga.PtrString(modelId),
				},
			}).
			Execute()

		receivedObjects := []string{}
		done := false
		for !done {
			select {
			case obj, ok := <-objectChan:
				if !ok {
					done = true
					break
				}
				receivedObjects = append(receivedObjects, obj.Object)
			case err := <-errorChan:
				if err != nil {
					t.Fatalf("Error received: %v", err)
				}
			case <-time.After(5 * time.Second):
				t.Fatalf("Test timed out")
			}
		}

		if len(receivedObjects) != len(objects) {
			t.Fatalf("Expected %d objects, got %d", len(objects), len(receivedObjects))
		}
	})
}
